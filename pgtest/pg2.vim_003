#! vim -u NONE
:set viminfo= " viminfoを読み込まない。
:set history=1000 " コマンドライン履歴の保存数を設定（例：1000個）。
:set wildmenu " コマンドラインでメニューによる補完を有効化。
:set wildmode=longest,list " 補完方法を設定（例：共通部分を補完後、候補をリスト表示）。
:set wildignore=*.o,*.obj,*~ " 補完対象から除外するファイルパターンを設定。
:set hlsearch " 検索語をハイライト表示。
:set noincsearch " 検索語をインクリメンタルにハイライト表示。
:set cpo-=< " <>記法を有効とする。
:set cpo-=C " 連結行のコメント継続を有効にする
:set laststatus=2 " ステータスラインを常に表示する。
:set mouse=a

:if !exists('g:term_trigger_key')
  :let g:term_trigger_key = "<F8>" " トリガーキーを定義する変数。デフォルトは<F8>。
:endif

" ルートメニュー定義
:let g:term_root_menu = [
      \ {'name': 'options',  'color': 'lightmagenta', 'clicked': 0, 'menu_str': 'options',  'width': 8,  'popup_winid': 0},
      \ {'name': 'terminal', 'color': 'lightgreen',   'clicked': 0, 'menu_str': 'terminal', 'width': 10, 'popup_winid': 0},
      \ {'name': 'title',    'color': 'lightcyan',    'clicked': 0, 'menu_str': 'TERMEXEC', 'width': 10, 'popup_winid': 0}]

" options子メニュー定義
:let g:term_options = [
      \ {'name': 'last_line', 'flag': 1, 'menu_str': '実行行マーク', 'menupid': 0, 'use_flag': 1},
      \ {'name': 'next_line', 'flag': 1, 'menu_str': '次の行に移動', 'menupid': 0, 'use_flag': 1},
      \ {'name': 'trim_spce', 'flag': 1, 'menu_str': '実行時行頭の空白を削除', 'menupid': 0, 'use_flag': 1}]

" terminal子メニュー定義
:let g:term_terminal = [
      \ {'name': 'add_term', 'flag': 0, 'menu_str': 'Terminalを追加', 'menupid': 0, 'use_flag': 0, 'func': 'CreateNewTerminal'},
      \ {'name': 'fukusuu', 'flag': 0, 'menu_str': '複数対応', 'menupid': 0, 'use_flag': 1},
      \ {'name': 'sayuu', 'flag': 0, 'menu_str': '左右に並べる', 'menupid': 0, 'use_flag': 1}]
      " {'name': 'jyouge','flag': 0,'menu_str': '上下に並べる', 'menupid': 0,'use_flag': 1}

" title子メニュー定義
:let g:term_title = []

" ターミナル一覧定義
:let g:term_list_max_cnt = 1
:let g:term_lists = []  " sample [{'term_name': 'term001', 'target_flg': 1,'log_name': "", 'last_wrote_line': 1, 'menupid': 0}] " ターミナル情報を保持するリスト。

" --- ヘルパー関数 ---

" リスト内の辞書要素を name キーで検索し、そのインデックスを返す
function! s:get_item_idx_by_name(list, item_name)
  let idx_list = filter(range(len(a:list)), 'a:list[v:val].name ==# a:item_name')
  return len(idx_list) > 0 ? idx_list[0] : -1
endfunction

" リスト内の辞書要素を指定されたキーと値で検索し、その要素自体を返す
function! s:get_item_by_kv(list, key, value)
  let items = filter(copy(a:list), 'v:val[a:key] ==# a:value') " copy() は defensive
  return len(items) > 0 ? items[0] : v:null
endfunction

" terminal一覧のポップアップアイテムを作成または更新する
function! s:create_or_update_terminal_list_item_popup(term_item_ref, index, base_col)
  let l:popup_options = {
        \ 'line': a:index + 2,
        \ 'col': a:base_col,
        \ 'minwidth': 30,
        \ 'highlight': 'hlterminal',
        \ 'padding': [0, 1, 0, 1],
        \ 'border': [0, 0, 0, 0]
        \ }

  let l:fukusuu_item = s:get_item_by_kv(g:term_terminal, "name", "fukusuu")
  let l:text_prefix = ''
  if l:fukusuu_item != v:null && l:fukusuu_item.flag
    let l:text_prefix = (a:term_item_ref.target_flg ? '[x]' : '[ ]')
  else
    let l:text_prefix = (a:term_item_ref.target_flg ? '(x)' : '( )')
  endif

  let l:item_text = printf('%s %s b(%d) w(%d)',
        \ l:text_prefix,
        \ a:term_item_ref.term_name,
        \ bufnr(a:term_item_ref.term_name),
        \ bufwinid(a:term_item_ref.term_name))

  if has_key(a:term_item_ref, 'menupid') && a:term_item_ref.menupid != 0
    try
      call popup_settext(a:term_item_ref.menupid, l:item_text)
    catch
      " ポップアップが存在しない場合 (例: ウィンドウが閉じられた後など)
      let a:term_item_ref.menupid = popup_create(l:item_text, l:popup_options)
    endtry
  else
    let a:term_item_ref.menupid = popup_create(l:item_text, l:popup_options)
  endif
endfunction

" --- 子メニュー処理関数 ---

" options子メニュー処理関数
:let g:options_func = {}
  " 子メニューを作成する関数
  :function! g:options_func.CreatePopup()
    :for c in range(len(g:term_options))
      :let l:menu_text = (g:term_options[c].flag ? '[x]' : '[ ]') . ' ' . g:term_options[c].menu_str
      :let l:option_popup_opts = {'line': 2 + c, 'col': winwidth(0) - 30, 'minwidth': 30, 'highlight': 'hloptions', 'padding': [0, 1, 0, 1], 'border': [0, 0, 0, 0]}
      :let g:term_options[c].menupid = popup_create(l:menu_text, l:option_popup_opts)
    :endfor
  :endfunction

  " 子メニューを削除する関数
  :function! g:options_func.DeletePopup()
    :for c in range(len(g:term_options))
      :if g:term_options[c].menupid != 0
        :call popup_close(g:term_options[c].menupid)
        :let g:term_options[c].menupid = 0
      :endif
    :endfor
  :endfunction

  " 子メニューを更新する関数
  :function! g:options_func.UpdatePopup()
    :for c in range(len(g:term_options))
      :if g:term_options[c].menupid != 0
        :let l:menu_text = (g:term_options[c].flag ? '[x]' : '[ ]') . ' ' . g:term_options[c].menu_str
        :call popup_settext(g:term_options[c].menupid, l:menu_text)
      :endif
    :endfor
  :endfunction

" terminal子メニュー処理関数
:let g:terminal_func = {}
  " 子メニューを作成する関数
  :function! g:terminal_func.CreatePopup()
    :redir >> log.txt
    " terminal一覧
    :for cnt_term in range(len(g:term_lists))
      :let l:option_popup_opts = {'line': cnt_term + 2, 'col': winwidth(0) - 64, 'minwidth': 30, 'highlight': 'hlterminal', 'padding': [0, 1, 0, 1], 'border': [0, 0, 0, 0]}
      :call s:create_or_update_terminal_list_item_popup(g:term_lists[cnt_term], cnt_term, winwidth(0) - 64)
    :endfor

    " terminal操作メニュー
    :for c in range(len(g:term_terminal))
      :let l:menu_text = ''
      :if g:term_terminal[c].use_flag
        :let l:menu_text = (g:term_terminal[c].flag ? '[x]' : '[ ]') . ' ' . g:term_terminal[c].menu_str
      :else
        :let l:menu_text = '    ' . g:term_terminal[c].menu_str
      :endif
      :let l:option_popup_opts = {'line': 2 + c, 'col': winwidth(0) - 30, 'minwidth': 30, 'highlight': 'hlterminal', 'padding': [0, 1, 0, 1], 'border': [0, 0, 0, 0]}
      :let g:term_terminal[c].menupid = popup_create(l:menu_text, l:option_popup_opts)
    :endfor
    :redir END
  :endfunction

  " 子メニューを削除する関数
  :function! g:terminal_func.DeletePopup()
    " terminal一覧
    :for cnt_term in range(len(g:term_lists))
      :if g:term_lists[cnt_term].menupid != 0
        :call popup_close(g:term_lists[cnt_term].menupid)
        :let g:term_lists[cnt_term].menupid = 0
      :endif
    :endfor

    " terminal操作メニュー
    :for c in range(len(g:term_terminal))
      :if g:term_terminal[c].menupid != 0
        :call popup_close(g:term_terminal[c].menupid)
        :let g:term_terminal[c].menupid = 0
      :endif
    :endfor
  :endfunction

  " 子メニューを更新する関数
  :function! g:terminal_func.UpdatePopup()
    " terminal一覧
    :for cnt_term in range(len(g:term_lists))
      :call s:create_or_update_terminal_list_item_popup(g:term_lists[cnt_term], cnt_term, winwidth(0) - 64)
    :endfor

    " terminal操作メニュー
    :for c in range(len(g:term_terminal))
      :if g:term_terminal[c].menupid != 0
        :let l:menu_text = ''
        :if g:term_terminal[c].use_flag
          :let l:menu_text = (g:term_terminal[c].flag ? '[x]' : '[ ]') . ' ' . g:term_terminal[c].menu_str
        :else
          :let l:menu_text = '    ' . g:term_terminal[c].menu_str
        :endif
        :call popup_settext(g:term_terminal[c].menupid, l:menu_text)
      :endif
    :endfor
  :endfunction

" title子メニュー処理関数
:let g:title_func = {}
  " 子メニューを作成する関数
  :function! g:title_func.CreatePopup()
    :for c in range(len(g:term_title))
      :let l:menu_text = (g:term_title[c].flag ? '[x]' : '[ ]') . ' ' . g:term_title[c].menu_str
      :let l:option_popup_opts = {'line': 2 + c, 'col': winwidth(0) - 30, 'minwidth': 30, 'highlight': 'hlterminal', 'padding': [0, 1, 0, 1], 'border': [0, 0, 0, 0]}
      :let g:term_title[c].menupid = popup_create(l:menu_text, l:option_popup_opts)
    :endfor
  :endfunction

  " 子メニューを削除する関数
  :function! g:title_func.DeletePopup()
    :for c in range(len(g:term_title))
      :if g:term_title[c].menupid != 0
        :call popup_close(g:term_title[c].menupid)
        :let g:term_title[c].menupid = 0
      :endif
    :endfor
  :endfunction

  " 子メニューを更新する関数
  :function! g:title_func.UpdatePopup()
    :for c in range(len(g:term_title))
      :if g:term_title[c].menupid != 0
        :let l:menu_text = (g:term_title[c].flag ? '[x]' : '[ ]') . ' ' . g:term_title[c].menu_str
        :call popup_settext(g:term_title[c].menupid, l:menu_text)
      :endif
    :endfor
  :endfunction

" --- 主要関数 ---

" ターミナルを表示する関数
:function! ShowTerminal()
  :let l:current_winid = win_getid() " 現在のウィンドウIDを取得します。
  :for l:term_info in g:term_lists " termに紐付くすべてのwinidをhideする
    :let l:term_winid = bufwinid(l:term_info.term_name)
    :if l:term_winid != -1
      :call win_gotoid(l:term_winid)
      :execute "hide"
      :call win_gotoid(l:current_winid)
    :endif
  :endfor
  :let l:fitst_split = 1
  :let l:sayuu_item = s:get_item_by_kv(g:term_terminal, "name", "sayuu")
  :let l:is_sayuu_split = (l:sayuu_item != v:null && l:sayuu_item.flag)

  :for l:term_info in g:term_lists " target_flgがオンのものを表示する
    :if l:term_info.target_flg
      :if l:fitst_split
        :let l:fitst_split = 0
        :execute "bo sp | buffer! " . bufnr(l:term_info.term_name)
      :else
        :if l:is_sayuu_split
          :execute "rightbelow vsplit | buffer! " . bufnr(l:term_info.term_name)
        :else
          :execute "bo sp | buffer! " . bufnr(l:term_info.term_name)
        :endif
      :endif
    :endif
  :endfor
  :call win_gotoid(l:current_winid)
  " g:term_lists一覧の表示更新
  :let l:terminal_menu_item = s:get_item_by_kv(g:term_root_menu, "name", "terminal")
  :if l:terminal_menu_item != v:null && l:terminal_menu_item.clicked
    :call g:terminal_func.UpdatePopup()
  :endif
:endfunction

" ターミナルを作成する関数
:function! CreateNewTerminal()
  :let l:term_name = 'term' . printf('%03d', g:term_list_max_cnt)
  :let g:term_list_max_cnt += 1

  :call term_start(['bash'], {'term_name': l:term_name, 'term_finish': 'close', 'hidden': 1})

  " 複数フラグをチェックしてオフの時の処理
  :let l:fukusuu_item = s:get_item_by_kv(g:term_terminal, "name", "fukusuu")
  :if l:fukusuu_item != v:null && !l:fukusuu_item.flag
    " 複数オプションオフなら既存は全てオフに
    :for cnt_term in range(len(g:term_lists))
      :let g:term_lists[cnt_term].target_flg = 0
    :endfor
  :endif

  " g:term_lists に追加
  :call add(g:term_lists, {'term_name': l:term_name, 'target_flg': 1, 'log_name': "", 'last_wrote_line': 1, 'menupid': 0})

  " g:term_lists の表示を更新
  :call ShowTerminal()

  " bashのプロンプトが表示されるまで待機
  :let l:start_time = reltime()
  :while reltime(l:start_time)[0] < 5
    :if getbufline(bufnr(l:term_name), 1, '$')[-1] =~# '.*[\$#].*' | :break | :endif
    :sleep 100m
  :endwhile

:endfunction

" カレント行のテキストをVimスクリプトとして実行する関数。
:function! ExecuteCurrentLineAsVimscript(line_content)
  " 取得したテキストをVimスクリプトとして実行。
  :try
    :execute a:line_content
  :catch /^Vim\%((\a\+)\)\=:E\d+:/
    :echohl ErrorMsg
    :echomsg "Error executing: " . v:exception
    :echohl None
  :endtry
:endfunction

" カレント行のテキストをBashコマンドとして実行する関数。
:function! ExecuteCurrentLineAsBash(line_content)

  " ターミナルが未作成であれば作成
  :if empty(g:term_lists)
    :call CreateNewTerminal()
  :endif

  :for l:term_info in g:term_lists " ターミナル情報を取得。
    :if !has_key(l:term_info, 'term_name') " 基本的にこの条件は満たされないはず
      :echomsg "term information is not found."
      :return
    :endif
    :if l:term_info.target_flg
      " コマンドを実行する。
      :if empty(a:line_content)
        :call term_sendkeys(bufnr(l:term_info.term_name), "\<CR>")
      :else
        :call term_sendkeys(bufnr(l:term_info.term_name), a:line_content . "\<CR>")
      :endif
    :endif
  :endfor
:endfunction

" カレント行をVimscriptまたはBashで実行する関数。
:function! ExecuteCurrentLine()
  :let l:line_content = getline(line('.')) " カレント行のテキストを取得。

  " 実行した行のsign処理。
  :let l:last_line_opt = s:get_item_by_kv(g:term_options, 'name', 'last_line')
  :if l:last_line_opt != v:null && l:last_line_opt.flag
    :call sign_define('TermExecuted', {'text': '->', 'texthl': 'Search'})
    :call sign_unplace('*', {'group': 'TermExecuted'}) " 同じグループの既存サインを全て削除
    :call sign_place(0, 'TermExecuted', 'TermExecuted', bufnr('%'), {'lnum': line('.')})
  :else
    :call sign_unplace('*', {'group': 'TermExecuted'})
  :endif

  " 次の非コメント行へ移動 (複数行コメントに対応)
  :let l:next_line_opt = s:get_item_by_kv(g:term_options, 'name', 'next_line')
  :if l:next_line_opt != v:null && l:next_line_opt.flag
    :let l:current_line = line('.')
    :let l:next_line_num = l:current_line + 1
    :while l:next_line_num <= line('$') && getline(l:next_line_num) =~# '^\s*#'
      :let l:next_line_num += 1
    :endwhile
    :if l:next_line_num <= line('$') && l:next_line_num != l:current_line " 同じ行に留まらないように
      :call cursor(l:next_line_num, 1)
    :endif
  :endif

  " あたまの空白のトリム
  :let l:trim_spce_opt = s:get_item_by_kv(g:term_options, 'name', 'trim_spce')
  :if l:trim_spce_opt != v:null && l:trim_spce_opt.flag
    :let l:line_content = substitute(l:line_content, '^\s\+', '', '')
  :endif

  " 実行
  :if l:line_content =~# '^\s*:'
    :call ExecuteCurrentLineAsVimscript(l:line_content) " 行の先頭が : ならvimscriptとして実行。
  :else
    :call ExecuteCurrentLineAsBash(l:line_content)
  :endif
:endfunction

" マウスクリック時に実行される関数
:function! ShowClickPosition()
  :redir >> log.txt
  :call getchar()
  :echo "行番号: " . v:mouse_lnum . ", 列番号: " . v:mouse_col . ", winid: " . v:mouse_winid

  " 子メニュー項目がクリックされたか確認(個別に分けるか)
  :for c_root_idx in range(len(g:term_root_menu))
    :let l:current_root_item_data = g:term_root_menu[c_root_idx]
    :if l:current_root_item_data.clicked " 対応するルートメニューが開いている場合のみ子メニューを処理
      :let l:sub_menu_list_var_name = "term_" . l:current_root_item_data.name
      :if exists('g:' . l:sub_menu_list_var_name)
        :let l:sub_menu_list_ref = get(g:, l:sub_menu_list_var_name) " 参照を取得
        :for item_idx in range(len(l:sub_menu_list_ref))
          :let l:item_ref = l:sub_menu_list_ref[item_idx] " 参照を取得
          :if v:mouse_winid == l:item_ref.menupid
            :if l:item_ref.use_flag " チェックボックス形式のメニュー
              :let l:item_ref.flag = !l:item_ref.flag " 参照を通じてフラグを更新
              :let l:func_dict_name = l:current_root_item_data.name . "_func"
              :if exists('g:' . l:func_dict_name)
                :let l:func_dict = get(g:, l:func_dict_name)
                :if has_key(l:func_dict, 'UpdatePopup')
                  :call l:func_dict.UpdatePopup()
                :endif
              :endif
            :else " 関数呼び出し形式のメニュー
              :if has_key(l:item_ref, 'func') && !empty(l:item_ref.func)
                :let Func = function(l:item_ref.func)
                :call Func()
                " CreateNewTerminal後はterminalメニューの更新が必要
                :if l:current_root_item_data.name ==# 'terminal'
                  :call g:terminal_func.UpdatePopup()
                :endif
              :endif
            :endif
            :redraw " クリック後すぐに再描画
            :redir END
            :return 0  " いずれかの子メニューが処理されたら終了
          :endif
        :endfor
      :endif
    :endif
  :endfor

  " rootメニューの押下の確認と処理 (共通で良いかな)
  :for c_root_idx in range(len(g:term_root_menu))
    :let l:current_root_item_ref = g:term_root_menu[c_root_idx] " 参照を取得
    :if v:mouse_winid == l:current_root_item_ref.popup_winid
      :let l:func_dict_name = l:current_root_item_ref.name . "_func"
      :let l:func_dict_exists = exists('g:' . l:func_dict_name)
      :let l:func_dict = l:func_dict_exists ? get(g:, l:func_dict_name) : {}

      :if l:current_root_item_ref.clicked == 0 " クリックされていなかったメニューを開く
        " 他のrootメニューは閉じるのでclicked
        :for cnt_root in filter(range(len(g:term_root_menu)), 'g:term_root_menu[v:val].clicked == 1')
          :let l:other_root_item_ref = g:term_root_menu[cnt_root] " 参照を取得
          :let l:other_func_dict_name = l:other_root_item_ref.name . "_func"
          :let l:other_func_dict_exists = exists('g:' . l:other_func_dict_name)
          :let l:other_func_dict = l:other_func_dict_exists ? get(g:, l:other_func_dict_name) : {}

          :let l:other_root_item_ref.clicked = 0 " 参照を通じて更新
          :call popup_setoptions(l:other_root_item_ref.popup_winid, {'highlight': 'hl' . l:other_root_item_ref.name})
          :if has_key(l:other_func_dict, 'DeletePopup')
            :call l:other_func_dict.DeletePopup()
          :endif
        :endfor
        :let l:current_root_item_ref.clicked = 1 " 参照を通じて更新
        :call popup_setoptions(l:current_root_item_ref.popup_winid, {'highlight': 'hl' . l:current_root_item_ref.name . "r"})
        :if has_key(l:func_dict, 'CreatePopup')
          :call l:func_dict.CreatePopup()
        :endif
      :else " クリックされていたメニューを閉じる
        :let l:current_root_item_ref.clicked = 0 " 参照を通じて更新
        :call popup_setoptions(l:current_root_item_ref.popup_winid, {'highlight': 'hl' . l:current_root_item_ref.name})
        :if has_key(l:func_dict, 'DeletePopup')
          :call l:func_dict.DeletePopup()
        :endif
      :endif
      :redraw
      :redir END
      :return
    :endif
  :endfor

  " 端末一覧が押されたか？
  :let l:fukusuu_item = s:get_item_by_kv(g:term_terminal, "name", "fukusuu")
  :let l:is_fukusuu_enabled = (l:fukusuu_item != v:null && l:fukusuu_item.flag)

  :for cnt_term in range(len(g:term_lists))
    :let l:current_term_item_ref = g:term_lists[cnt_term] " 参照を取得
    :if v:mouse_winid == l:current_term_item_ref.menupid " 端末一覧のアイテムが押されたか？
      :if bufnr(l:current_term_item_ref.term_name) == -1 " 押されたterm_nameがbufを持ってなければg:term_listsから削除
        :call popup_close(l:current_term_item_ref.menupid) " 先にポップアップを閉じる
        :call remove(g:term_lists, cnt_term)
        :call g:terminal_func.UpdatePopup() " リスト更新
        :redraw
        :redir END
        :return
      :endif

      :if !l:is_fukusuu_enabled " 「複数対応」がオフか？
        " target_flgをゼロクリアして押されたもののみtarget_flgを1に変更！
        :for c_target_clear_idx in range(len(g:term_lists))
          :let g:term_lists[c_target_clear_idx].target_flg = 0 " 直接リストの要素を更新
        :endfor
        :let l:current_term_item_ref.target_flg = 1 " 参照を通じて更新
      :else " 「複数対応」がオン時の処理
        :let l:current_term_item_ref.target_flg = !l:current_term_item_ref.target_flg " 参照を通じて更新
      :endif
      :call ShowTerminal() " 表示更新
      :redraw
      :redir END
      :return
    :endif
  :endfor

  " ボタンが「複数対応」ボタンだったら（もうトグルは済み）
  :if l:fukusuu_item != v:null && v:mouse_winid == l:fukusuu_item.menupid
    :if !l:fukusuu_item.flag " 「複数対応」がオフになった場合
      " 最初の有効なターミナルのみを選択状態にするか、全てオフにするか。現状は全てオフ。
      :for c_target_clear_idx in range(len(g:term_lists))
        :let g:term_lists[c_target_clear_idx].target_flg = 0
      :endfor
      " もし一つもターミナルがない場合は何もしない、あれば最初のものを選択状態にしても良い
      :if !empty(g:term_lists)
         " let g:term_lists[0].target_flg = 1 " 例：最初のものを選択
      :endif
    :endif
    :call ShowTerminal() " 表示更新
    :redraw
    :redir END
    :return
  :endif

  " 再描画
  :redraw

  " 元のマウスクリックイベントを実行
  " :normal! <LeftMouse> だめだ動かん
  :redir END
:endfunction

" vimスクリプトファイルでロードされたときだけこの設定を有効にする。
:augroup ExecuteCurrentLine
  :autocmd!
  " キーマッピングを定義する際に、g:term_trigger_key を使用する。
  :execute 'autocmd VimEnter,BufEnter,BufReadPost * :nnoremap <buffer><silent>' . g:term_trigger_key . ' :call ExecuteCurrentLine()<CR>'
  :noremap <script> <LeftMouse> :call ShowClickPosition()<CR>
 :augroup END

:" root_menuの表示
  :for c in range(len(g:term_root_menu))
    :execute 'highlight hl' . g:term_root_menu[c].name . "r ctermfg=" . g:term_root_menu[c].color . " ctermbg=black"
    :execute 'highlight hl' . g:term_root_menu[c].name . " ctermfg=black ctermbg=" . g:term_root_menu[c].color
  :endfor

  :let posx = winwidth(0)
  :for c in range(len(g:term_root_menu))
    :let opts = {}
    :let opts.line = 1
    :let posx -= g:term_root_menu[c].width
    :let opts.col = posx
    :let posx -= 1
    :let opts.pos = 'botleft'
    :let opts.padding = [0, 1, 0, 1]
    :let opts.border = [0, 0, 0, 0]
    :let opts.highlight = 'hl' . g:term_root_menu[c].name
    :let menu_str = g:term_root_menu[c].menu_str
    :let g:term_root_menu[c].popup_winid = popup_create(menu_str, opts)
  :endfor
